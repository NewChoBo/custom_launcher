# Copilot 사용 지침서: Custom Desktop App (Flutter Desktop)

## 1. 프로젝트 개요

### 목적
- **Custom Launcher**: 고도로 사용자 정의 가능하고 효율적인 애플리케이션 실행 경험 제공
- **주요 기능**: 애플리케이션 관리, 커스터마이징, 빠른 실행, 시스템 통합, 크로스 플랫폼 지원
- **기술 스택**: Flutter (Dart), Riverpod (상태 관리), 플랫폼별 서비스 통합

### 아키텍처 원칙
- **클린 아키텍처**: 데이터, 도메인, 프레젠테이션 계층 분리
- **모듈성**: 기능별 명확한 분리
- **확장성**: 향후 플러그인 시스템 지원
- **성능**: 빠른 실행과 낮은 리소스 사용

## 2. 코드 스타일 및 컨벤션

### 기본 규칙
- **Dart/Flutter 표준 컨벤션** 준수
- **2-space 들여쓰기** 사용
- **PascalCase** (클래스, 메서드), **camelCase** (변수, 함수)
- **절대 import** 사용: `package:custom_launcher/...`
- **한국어 주석** 사용 (코드 내 설명)

### 파일 구조 규칙
```
lib/
├── main.dart                     # 앱 진입점
├── core/                         # 핵심 서비스
│   ├── providers/                # 전역 Riverpod 프로바이더
│   ├── services/                 # 플랫폼별 서비스
│   └── utils/                    # 유틸리티
└── features/                     # 기능별 모듈
    └── launcher/                 # 런처 기능
        ├── data/                 # 데이터 계층
        ├── domain/               # 도메인 계층
        │   ├── entities/         # 엔티티
        │   ├── repositories/     # 리포지토리 인터페이스
        │   └── usecases/         # 유스케이스 (통합된 폴더)
        └── presentation/         # 프레젠테이션 계층
```

### 네이밍 컨벤션
- **클래스**: `PascalCase` (예: `AppModel`, `CustomCardWidget`)
- **메서드/변수**: `camelCase` (예: `getAppSettings`, `appDataRepository`)
- **상수**: `SCREAMING_SNAKE_CASE` (예: `DEFAULT_WINDOW_SIZE`)
- **파일명**: `snake_case` (예: `app_model.dart`, `custom_card_widget.dart`)

## 3. 개발 원칙

### 코드 품질
- **안정성**: 버그 없는 견고한 코드
- **확장성**: 미래 성장을 고려한 설계
- **가독성**: 이해하기 쉽고 유지보수 가능한 코드
- **테스트 가능성**: 단위 테스트 작성 가능한 구조

### 의존성 관리
- **최신 버전** 우선 사용
- **공식 패키지** 선호
- **불필요한 복잡성** 회피
- **성능 영향** 고려

### 에러 처리
- **try-catch** 후 로깅
- **사용자 친화적** 에러 메시지
- **graceful degradation** 구현

## 4. 주요 패키지 및 버전

### 핵심 의존성
```yaml
# 상태 관리
flutter_riverpod: ^2.6.1

# 데스크톱 기능
tray_manager: ^0.5.0
window_manager: ^0.5.0
screen_retriever: ^0.2.0

# UI 및 데이터
json_dynamic_widget: ^10.0.1
reorderables: ^0.6.0
path_provider: ^2.1.3
equatable: ^2.0.5
json_annotation: ^4.8.1
collection: ^1.18.0
cupertino_icons: ^1.0.8
```

### 개발 의존성
```yaml
flutter_lints: ^5.0.0
json_serializable: ^6.7.1
build_runner: ^2.4.9
```

## 5. Repository 패턴 가이드라인

### Repository 구조
```dart
// 도메인 계층: 추상 인터페이스
abstract class AppRepository {
  Future<List<AppInfo>> getAppInfoList();
  Future<AppSettings> getAppSettings();
}

abstract class SettingsRepository {
  AppSettings get settings;
  Future<void> initialize();
}

// 데이터 계층: 구현체
class AppRepositoryImpl implements AppRepository {
  @override
  Future<List<AppInfo>> getAppInfoList() async {
    // 구현 로직
  }
  
  @override
  Future<AppSettings> getAppSettings() async {
    // 구현 로직
  }
}
```

### UseCase 패턴
```dart
// usecases/ 폴더 (통합된 단일 폴더 사용)
class GetAppSettings {
  final AppRepository repository;

  GetAppSettings(this.repository);

  Future<AppSettings> call() async {
    return await repository.getAppSettings();
  }
}

class GetSupportedApps {
  final AppRepository repository;

  GetSupportedApps(this.repository);

  Future<List<AppInfo>> call() async {
    return await repository.getAppInfoList();
  }
}
```

## 6. Copilot 사용 가이드라인

### 코드 생성 전 확인사항

1. **프로젝트 구조 파악**
   - lib/ 폴더 구조와 파일 위치 확인
   - 중복 폴더 구조 회피 (usecases 폴더로 통일)

2. **기존 코드 스타일 분석**
   - 네이밍 규칙, 들여쓰기, 예외 처리 방식 학습
   - 기존 패턴과 일관성 유지

3. **아키텍처 원칙 준수**
   - 클린 아키텍처 계층 분리
   - 관심사 분리 원칙
   - 의존성 주입 패턴

### 코드 작성 규칙

1. **import 문**
   ```dart
   import 'package:custom_launcher/core/services/window_service.dart';
   import 'package:custom_launcher/features/launcher/domain/entities/app_info.dart';
   
   import '../services/window_service.dart';
   ```

2. **클래스 구조**
   ```dart
   class AppModel {
     final String id;
     final String name;
     final String path;
     
     const AppModel({
       required this.id,
       required this.name,
       required this.path,
     });
     
     factory AppModel.fromJson(Map<String, dynamic> json) {
       return AppModel(
         id: json['id'] as String,
         name: json['name'] as String,
         path: json['path'] as String,
       );
     }
     
     AppModel copyWith({
       String? id,
       String? name,
       String? path,
     }) {
       return AppModel(
         id: id ?? this.id,
         name: name ?? this.name,
         path: path ?? this.path,
       );
     }
   }
   ```

3. **Riverpod 프로바이더**
   ```dart
   final appRepositoryProvider = Provider<AppRepository>((ref) {
     return AppRepositoryImpl();
   });
   
   final getAppSettingsProvider = FutureProvider<AppSettings>((ref) async {
     final repository = ref.read(appRepositoryProvider);
     return await repository.getAppSettings();
   });
   ```

### 주석 및 태그 패턴

| 태그 | 용도 |
|------|------|
| `// TODO:` | 새 기능 작성 요청 |
| `// FIXME:` | 잘못된 제안 수정 요청 |
| `// EXAMPLE:` | 예시 코드 생성 요청 |
| `// NOTE:` | 정보 부족 시 안내 |
| `// DO NOT MODIFY` | 보호할 핵심 로직 표시 |

## 7. 작업 프로세스

### 1단계: 요구사항 분석
- 사용자 요청이 질문인지 요청인지 판별
- 질문: 옵션 제시 및 설명 제공
- 요청: 코드 작업 계획 제안 및 승인 후 실행

### 2단계: 계획 수립
```text
Copilot: 변경 계획 제안
1) 수정 파일: features/launcher/domain/usecases/get_app_settings.dart
2) 작업 내용: GetAppSettings usecase 구현
계속 진행해도 될까요?
```

### 3단계: 코드 구현
- 기존 코드 스타일 준수
- 테스트 가능한 구조로 작성
- 에러 처리 포함

### 4단계: 검증
- flutter analyze 실행
- 코드 품질 확인
- 기능 테스트

## 8. 특정 기능 구현 가이드

### 윈도우 관리
```dart
class WindowService {
  static Future<void> initialize(AppSettings settings) async {
    await windowManager.setSize(settings.window.size.toSize());
    await windowManager.setPosition(settings.window.position.toOffset());
    await windowManager.setAlwaysOnTop(
      settings.window.behavior.windowLevel == 'alwaysOnTop'
    );
  }
}
```

### 시스템 트레이
```dart
class SystemTrayService {
  Future<void> initialize() async {
    await trayManager.setIcon('assets/icons/app_icon.ico');
    await trayManager.setContextMenu([
      MenuItem(key: 'show', label: 'Show'),
      MenuItem(key: 'hide', label: 'Hide'),
      MenuItem(key: 'quit', label: 'Quit'),
    ]);
  }
}
```

### 동적 레이아웃
```dart
class DynamicLayoutWidget extends StatelessWidget {
  final Map<String, dynamic> layoutConfig;
  
  const DynamicLayoutWidget({required this.layoutConfig, super.key});
  
  @override
  Widget build(BuildContext context) {
    return JsonWidgetData.fromDynamic(
      layoutConfig,
      registry: JsonWidgetRegistry.instance,
    );
  }
}
```

## 9. 테스트 가이드라인

### 단위 테스트
```dart
void main() {
  group('GetAppSettings', () {
    test('should return app settings from repository', () async {
      final mockRepository = MockAppRepository();
      final usecase = GetAppSettings(mockRepository);
      
      final result = await usecase.call();
      
      expect(result, isA<AppSettings>());
    });
  });
}
```

### 위젯 테스트
```dart
void main() {
  testWidgets('CustomCardWidget displays app info', (tester) async {
    final app = AppModel(id: '1', name: 'Test App', path: '/test');
    
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: CustomCardWidget(app: app),
        ),
      ),
    );
    
    expect(find.text('Test App'), findsOneWidget);
  });
}
```

## 10. 빌드 및 실행 명령어

### Windows 개발 환경 (PowerShell)
```powershell
# 의존성 설치
flutter pub get

# Windows 데스크톱 실행
flutter run -d windows

# 코드 분석
flutter analyze

# 테스트 실행
flutter test

# 프로젝트 정리
flutter clean
```

### macOS 개발 환경 (Terminal)
```bash
# 의존성 설치
flutter pub get

# macOS 데스크톱 실행
flutter run -d macos

# 코드 분석
flutter analyze

# 테스트 실행
flutter test

# 프로젝트 정리
flutter clean
```

### Linux 개발 환경 (Terminal)
```bash
# 의존성 설치
flutter pub get

# Linux 데스크톱 실행
flutter run -d linux

# 코드 분석
flutter analyze

# 테스트 실행
flutter test

# 프로젝트 정리
flutter clean
```

### 크로스 플랫폼 빌드 명령어
```bash
# 모든 플랫폼 릴리즈 빌드
flutter build windows --release
flutter build macos --release
flutter build linux --release

# 개발 빌드 (디버그 정보 포함)
flutter build windows
flutter build macos
flutter build linux
```

## 11. 크로스 플랫폼 개발 가이드라인

### 플랫폼별 고려사항

#### Windows 특화
```dart
// Windows 시스템 통합
class WindowsPlatformService {
  static const platform = MethodChannel('com.example.windows');
  
  Future<String> getWindowsVersion() async {
    return await platform.invokeMethod('getWindowsVersion');
  }
  
  Future<void> setRegistryValue(String key, String value) async {
    await platform.invokeMethod('setRegistry', {'key': key, 'value': value});
  }
}
```

#### macOS 특화
```dart
// macOS 시스템 통합
class MacOSPlatformService {
  static const platform = MethodChannel('com.example.macos');
  
  Future<void> requestAccessibilityPermission() async {
    await platform.invokeMethod('requestAccessibility');
  }
  
  Future<void> addToStartupItems() async {
    await platform.invokeMethod('addToStartup');
  }
}
```

#### Linux 특화
```dart
// Linux 시스템 통합
class LinuxPlatformService {
  static const platform = MethodChannel('com.example.linux');
  
  Future<String> getDesktopEnvironment() async {
    return await platform.invokeMethod('getDesktopEnv');
  }
  
  Future<void> createDesktopEntry() async {
    await platform.invokeMethod('createDesktopEntry');
  }
}
```

### 플랫폼 감지 및 분기 처리
```dart
import 'dart:io';

class PlatformUtils {
  static bool get isWindows => Platform.isWindows;
  static bool get isMacOS => Platform.isMacOS;
  static bool get isLinux => Platform.isLinux;
  
  static String get platformName {
    if (isWindows) return 'Windows';
    if (isMacOS) return 'macOS';
    if (isLinux) return 'Linux';
    return 'Unknown';
  }
  
  static String get configPath {
    if (isWindows) return r'%APPDATA%\custom_launcher';
    if (isMacOS) return '~/Library/Application Support/custom_launcher';
    if (isLinux) return '~/.config/custom_launcher';
    throw UnsupportedError('Unsupported platform');
  }
}
```

### 플랫폼별 UI 적응
```dart
class PlatformAdaptiveWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    if (PlatformUtils.isMacOS) {
      return CupertinoButton(
        onPressed: () {},
        child: Text('macOS Style'),
      );
    } else {
      return ElevatedButton(
        onPressed: () {},
        child: Text('Material Style'),
      );
    }
  }
}
```

## 12. 배포 및 패키징 전략

### Windows 배포
```powershell
# Windows용 실행 파일 빌드
flutter build windows --release

# Inno Setup을 이용한 설치 프로그램 생성 (별도 설정 필요)
# - custom_launcher_setup.exe 생성
# - 레지스트리 등록, 바로가기 생성

# Microsoft Store 배포용 MSIX 패키징
flutter pub add msix
flutter pub get
flutter build windows --release
flutter pub run msix:create
```

### macOS 배포
```bash
# macOS용 앱 빌드
flutter build macos --release

# 앱 번들 코드 사이닝
codesign --force --verify --verbose --sign "Developer ID Application: Your Name" \
  build/macos/Build/Products/Release/custom_launcher.app

# DMG 파일 생성 (선택사항)
# create-dmg 도구 사용 또는 수동 생성

# Mac App Store 배포용 설정
# - Xcode에서 Archive 및 Upload
# - App Store Connect에서 심사 제출
```

### Linux 배포
```bash
# Linux용 실행 파일 빌드
flutter build linux --release

# AppImage 생성 (권장)
# appimagetool 사용하여 portable 실행 파일 생성

# Snap 패키지 생성
snapcraft init
# snapcraft.yaml 설정 후
snapcraft

# Flatpak 패키지 생성 (선택사항)
# flatpak-builder 사용

# 데비안/우분투용 .deb 패키지
# dpkg-deb 도구 사용
```

### 크로스 플랫폼 배포 자동화
```yaml
# GitHub Actions 예시 (.github/workflows/release.yml)
name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - run: flutter build windows --release
      - uses: actions/upload-artifact@v3

  build-macos:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - run: flutter build macos --release
      - uses: actions/upload-artifact@v3

  build-linux:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - run: flutter build linux --release
      - uses: actions/upload-artifact@v3
```

## 13. 문제 해결

### 일반적인 이슈
1. **import 오류**: 절대 경로 사용 확인
2. **빌드 오류**: `flutter clean` 후 `flutter pub get`
3. **상태 관리 오류**: Riverpod 프로바이더 구조 확인
4. **플랫폼별 이슈**: 플랫폼 채널 구현 확인
5. **중복 폴더**: usecases 폴더로 통일

### 플랫폼별 디버깅

#### Windows 환경
```powershell
# Windows 특정 로그 확인
flutter logs

# Windows 빌드 캐시 정리
flutter clean
Remove-Item -Recurse -Force windows/flutter/ephemeral

# 의존성 재설치
flutter pub get
```

#### macOS 환경
```bash
# macOS 특정 로그 확인
flutter logs

# macOS 빌드 캐시 정리
flutter clean
rm -rf macos/Flutter/ephemeral

# 의존성 재설치
flutter pub get

# Xcode 빌드 오류 시
open macos/Runner.xcworkspace
```

#### Linux 환경
```bash
# Linux 특정 로그 확인
flutter logs

# Linux 빌드 캐시 정리
flutter clean
rm -rf linux/flutter/ephemeral

# 시스템 의존성 확인 (Ubuntu/Debian)
sudo apt-get update
sudo apt-get install libgtk-3-dev libblkid-dev liblzma-dev

# 의존성 재설치
flutter pub get
```

### 크로스 플랫폼 호환성 테스트
```dart
// 플랫폼별 테스트 스위트
void main() {
  group('Platform Compatibility Tests', () {
    testWidgets('UI adapts to platform', (tester) async {
      // 플랫폼별 UI 요소 테스트
    });
    
    test('File paths work on all platforms', () {
      // 파일 경로 호환성 테스트
    });
    
    test('Platform services are available', () {
      // 플랫폼별 서비스 가용성 테스트
    });
  });
}
```

### 디버깅 팁
- debugPrint 사용하여 로그 출력
- Flutter Inspector 활용
- Hot Reload 활용하여 빠른 개발
- 플랫폼별 네이티브 디버그 도구 활용
- 크로스 플랫폼 테스트를 위한 VM/Container 환경 구축

## 14. 보안 고려사항

### AI 사용 시 주의사항
- 민감한 정보 (API 키, 비밀번호) 절대 포함 금지
- 코드 검토 필수: AI 생성 코드는 항상 검토 후 사용
- 보안 취약점 확인: 입력 검증, 에러 처리 등
- 의존성 검토: 새 패키지 추가 시 보안 영향 평가

### 플랫폼별 보안 고려사항

#### 모든 플랫폼 공통
```dart
// 암호화된 설정 저장
class SecureStorage {
  static const _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      groupId: 'com.example.custom_launcher',
    ),
    lOptions: LinuxOptions(),
    wOptions: WindowsOptions(),
    mOptions: MacOsOptions(),
  );
}
```

#### Windows
- 코드 사이닝 인증서 사용
- Windows Defender SmartScreen 고려
- UAC(User Account Control) 권한 최소화

#### macOS
- Apple Developer Program 가입 필수
- 코드 사이닝 및 공증(Notarization) 필요
- Gatekeeper 정책 준수

#### Linux
- 패키지 서명 권장
- AppArmor/SELinux 정책 고려
- 최소 권한 원칙 적용

### 데이터 보호
- 로컬 저장소 사용 시 민감한 데이터 암호화
- 플랫폼별 파일 권한 적절히 설정
- 에러 로그에 민감한 정보 포함 금지
- 플랫폼별 보안 가이드라인 준수

## 15. 성능 최적화

### 메모리 관리
- Dispose 패턴 적절히 사용
- 이미지 캐싱 구현
- 불필요한 리빌드 방지
- 플랫폼별 메모리 제약사항 고려

### 렌더링 최적화
- const 생성자 활용
- ListView.builder 사용
- RepaintBoundary 적절히 적용
- 플랫폼별 렌더링 엔진 특성 고려

### 플랫폼별 성능 최적화

#### Windows
- Windows 데스크톱 환경 최적화
- DPI 인식 설정
- 시스템 리소스 효율적 사용

#### macOS
- Retina 디스플레이 최적화
- macOS 시스템 통합 최적화
- 배터리 효율성 고려

#### Linux
- 다양한 데스크톱 환경 호환성
- X11/Wayland 호환성
- 시스템 자원 최적화